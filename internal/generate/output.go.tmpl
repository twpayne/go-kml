{{- $namespace := .Namespace -}}
{{- $gxPrefix := "" -}}
{{- if eq $namespace "gx:" -}}
{{- $gxPrefix = "Gx" -}}
{{- end -}}
// Code generated by github.com/twpayne/go-kml/v3/internal/generate. DO NOT EDIT.

package kml

import (
	"encoding/xml"
	"fmt"
	"image/color"
	"strconv"
	"time"
)

{{- range .Schema.SimpleType }}
{{- if or (ne .Restriction.Base "string") (or (not (hasSuffix "EnumType" .Name))) }}
{{-	continue }}
{{- end }}
{{- $typeName := printf "%s%s" $gxPrefix (.Name | trimSuffix "Type" | titleFirst) }}

// {{ aOrAn $typeName | titleFirst }} is {{ aOrAn .Name }}.
type {{ $typeName }} string

func (e {{ $typeName}}) String() string { return string(e) }

// {{ $typeName }}s.
const (
{{- if and (eq $namespace "gx:") (eq .Name "altitudeModeEnumType") }}
	GxAltitudeModeClampToGround    GxAltitudeModeEnum = "clampToGround"
	GxAltitudeModeRelativeToGround GxAltitudeModeEnum = "relativeToGround"
	GxAltitudeModeAbsolute         GxAltitudeModeEnum = "absolute"
{{- end }}
{{- range .Restriction.Enumeration }}
	{{ $typeName | trimSuffix "Enum" }}{{ .Value | titleFirst }} {{ $typeName }} = "{{ .Value }}"
{{- end }}
)
{{- end }}

{{- range .Schema.Element }}
{{- if or .Abstract (eq .Name "Data" "Scale" "Schema" "SchemaData" "SimpleArrayField" "SimpleData" "SimpleField" "Snippet" "Style" "StyleMap" "angles" "coord" "coordinates" "kml" "linkSnippet" "maxSnippetLines" "option" "snippet" "value") }}
{{- continue }}
{{- else if eq .Name (.Name | titleFirst) "innerBoundaryIs" "outerBoundaryIs" }}
{{- $name := printf "%s%s" $gxPrefix (.Name | nameToGoName | titleFirst ) }}
{{- $elementTypeName := printf "%sElement" $name }}

// {{ aOrAn $elementTypeName | titleFirst }} is {{ aOrAn .Name }} element.
type {{ $elementTypeName }} struct {
	Children []Element
}

// {{ $name }} returns a new {{ $elementTypeName }}.
func {{ $name }}(children ...Element) *{{ $elementTypeName }} {
	return &{{ $elementTypeName }}{
		Children: children,
	}
}

// Append appends children to e.
func (e *{{ $elementTypeName }}) Append(children ...Element) *{{ $elementTypeName }} {
	e.Children = append(e.Children, children...)
	return e
}

// MarshalXML implements encoding/xml.Marshaler.MarshalXML.
func (e *{{ $elementTypeName }}) MarshalXML(encoder *xml.Encoder, _ xml.StartElement) error {
	startElement := xml.StartElement{Name: xml.Name{Local: "{{ $namespace }}{{ .Name }}"}}
	return encodeElementWithChildren(encoder, startElement, e.Children)
}
{{- else }}

{{- $name := printf "%s%s" $gxPrefix (.Name | nameToGoName | titleFirst ) }}
{{- $elementTypeName := printf "%sElement" $name }}
{{- $valueTypeName := .Type | xsdTypeToGoType }}
{{- if eq .Name "delayedStart" "duration" "maxSessionLength" "minRefreshPeriod" "refreshInterval" "viewRefreshTime" }}
{{- $valueTypeName = "time.Duration" }}
{{- end }}

// {{ aOrAn $elementTypeName | titleFirst }} is {{ aOrAn .Name }} element.
type {{ $elementTypeName }} struct {
	Value {{ $valueTypeName }}
}

// {{ $name }} returns a new {{ $elementTypeName }}.
func {{ $name }}(value {{ $valueTypeName }}) *{{ $elementTypeName }} {
	return &{{ $elementTypeName }}{
		Value: value,
	}
}

// MarshalXML implements encoding/xml.Marshaler.MarshalXML.
func (e *{{ $elementTypeName }}) MarshalXML(encoder *xml.Encoder, _ xml.StartElement) error {
{{- if eq $valueTypeName "Vec2" }}
	startElement := xml.StartElement{
		Name: xml.Name{Local: "{{ $namespace }}{{ .Name }}"},
		Attr: e.Value.attr(),
	}
	return encodeElement(encoder, startElement)
{{- else }}
	startElement := xml.StartElement{Name: xml.Name{Local: "{{ $namespace }}{{ .Name }}"}}
{{- if eq $valueTypeName "bool" }}
	var charData xml.CharData
	if e.Value {
		charData = xml.CharData("1")
	} else {
		charData = xml.CharData("0")
	}
{{- else if eq $valueTypeName "color.Color" }}
	red, green, blue, alpha := e.Value.RGBA()
	charData := xml.CharData(fmt.Sprintf("%02x%02x%02x%02x", alpha/256, blue/256, green/256, red/256))
{{- else if eq $valueTypeName "float64" }}
	charData := xml.CharData(strconv.FormatFloat(e.Value, 'f', -1, 64))
{{- else if eq $valueTypeName "int" }}
	charData := xml.CharData(strconv.Itoa(e.Value))
{{- else if eq $valueTypeName "string" }}
	charData := xml.CharData(e.Value)
{{- else if eq $valueTypeName "time.Duration" }}
	seconds := float64(e.Value) / float64(time.Second)
	charData := xml.CharData(strconv.FormatFloat(seconds, 'f', -1, 64))
{{- else if eq $valueTypeName "time.Time" }}
	charData := xml.CharData(e.Value.Format(time.RFC3339))
{{- else if hasSuffix "Enum" $valueTypeName }}
	charData := xml.CharData(e.Value)
{{- end }}
	return encodeElementWithCharData(encoder, startElement, charData)
{{- end }}
}
{{- end }}
{{- end }}